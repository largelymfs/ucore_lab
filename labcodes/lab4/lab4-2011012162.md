###练习1：分配并初始化一个进程控制块（需要编码）
####设计过程：
> 创建一个进程控制块的过程分成下面几步:
> * 将进程状态设置为`PROC_UNINIT`
> * 初始化进程编号，运行数目，堆栈，父进程信息
> * 初始化内存信息，上下文信息，页表信息
> * 初始化进程名称

####请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？
>`context`的作用是保存程序切换之前的所有寄存器的值，这样就可以在从别的进程切换之后继续与原来的运行状态继续运行。
> `tf`的作用是保存程序在进入中断之前的所有寄存器，段选择子和错误码寄存器的值。这样可以在进程切换回来之后继续在原来的状态下运行。	

###练习2：为新创建的内核线程分配资源（需要编码）
####设计过程：
>为内核线程分配资源的过程分成下面几步：
>* 分配一个进程控制块
>* 分配给这个线程堆栈空间
>* 分配内存空间给这个线程
>* 设置中断状态寄存器和上下文状态存储寄存器
>* 屏蔽中断请求
>	* 将这个进程加入哈希表
>	* 将这个进程加入状态链表
>* 恢复中断请求
>* 唤起进程

####请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。
> ucore会通过`get_pid`函数为每个新的fork线程分配唯一的id，这个函数中维护了`next_safe`变量用来寻找下一个线程名称，这样每次在分配的时候进行遍历便可以给每一个线程分配一个唯一的id。


###练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）
> 进程切换分成下面几个步骤：
> * 屏蔽中断请求
> * 将`current`指向当前进程
> * 加载堆栈基址，切换`cr3`寄存器
> * 调用`switch to`函数
> * 解除屏蔽中断状态

####在本实验的执行过程中，创建且运行了几个内核线程？
> 本实验运行了`idle_proc`和`init_proc`两个内核线程。

####语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由
> 这两句话的作用是对中断请求进行屏蔽，因为我们进行进程切换的时候，无法预料的中断会影响整个系统进程切换的正确性，造成不可弥补的错误，因此需要进行中断屏蔽，使用`local_intr_save`进行中断屏蔽，最后使用`local_intr_restore`进行中断屏蔽的清除工作。