#Lab5 report


##练习1:加载应用程序并执行(需要编码)
`do_execv`函数调用`load_icode`(位于kern/process/proc.c中)来加载并解析一个处于内存中的ELF执行文件格式的应用程
序,建立相应的用户内存空间来放置应用程序的代码段、数据段等,且要设置好proc_struct结构中的成员变量trapframe中的
内容,确保在执行此进程后,能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。
请在实验报告中简要说明你的设计实现过程。

设计实现过程:
> 正确设置trapframe的内容:
> 1.设置cs代码段为USR_CS(用户代码段)
> 2.设置ds(包括es和ss)数据段为USER_DS
> 3.设置esp为USTACKTOP
> 4.设置eip为elf->e_entry(用户程序的入口地址)
> 5.设置eflags为FL_IF,用来产生中断

请在实验报告中描述当创建一个用户态进程并加载了应用程序后,CPU是如何让这个应用程序最终在用户态执行起来的。即
这个用户态进程被ucore选择占用CPU执行(RUNNING态)到具体执行应用程序第一条指令的整个经过。

>创建一个用户进程之后，通过`load_icode`进行程序的运行，具体是设置用户堆栈，建立好虚拟地址与物理地址的映射关系，建立页表。改写trapframe，以便能够让CPU转到用户特权级，回到用户态的内存空间，能够跳转到用户进程进行执行，并且确保用户态可以进行中断响应，然后`initproc`进行返回，切换到用户处进行执行。

##练习2:父进程复制自己的内存空间给子进程(需要编码)
创建子进程的函数do_fork在执行中将拷贝当前进程(即父进程)的用户内存地址空间中的合法内容到新进程中(子进程),
完成内存资源的复制。具体是通过copy_range函数(位于kern/mm/pmm.c中)实现的,请补充copy_range的实现,确保能
够正确执行。
设计实现过程:
> 使用两次`page2kva`得到需要进行拷贝的地址`src`和`des`，然后通过`memcpy`进行复制，最后建立物理页与虚拟页的映射。

请在实验报告中简要说明如何设计实现”Copy on Write机制“,给出概要设计,鼓励给出详细设计。
共享父进程的内存空间，从而免除重新拷贝，除非要执行写操作。当一个用户父进程创建自己的子进程时,父进程会把其申请的用户空间设置为只读,子进程可共享父进程占用的用户内存空间中的页面(这就是一个共享的资源)。当其中任何一个进程修改此用户内存空间中的某页面时,ucore会通过page	fault异常获知该操作,并完成拷贝内存页面,使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。

##练习3:阅读分析源代码,理解进程执行fork/exec/wait/exit的实现,以及系统调用的实现(不需要编码)
> * `fork`调用`do_fork`，最后调用`wakeup_proc`，这是一个系统调用`SYS_fork`
> * `exec`调用`do_execv`，这是一个系统调用`SYS_exec`
> * `wait`调用`do_wait`，这是一个系统调用`SYS_wait`
> * `exit`调用`do_exit`，这是一个系统调用`SYS_exit`
> * 系统调用实现：首先调用对应的中断描述符，这个特定中断时专门对于用户进行设计的，在`syscall`中，我们根据不同的系统调用号码进行系统调用的选择。

请在实验报告中简要说明你对fork/exec/wait/exit函数的分析。并回答如下问题:

请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?
> `fork`父进程通过拷贝自己复制出子进程。
> `exec`使用一个程序对另外一个进程进行复制。
> `wait`等待子进程或者IO操作的结束
> `exit`进程退出，可以触发父进程的`wait`条件

请给出ucore中一个用户态进程的执行状态生命周期图(包执行状态,执行状态之间的变换关系,以及产生变换的事件或
函数调用)。(字符方式画即可)

> * 进入就绪队列 ->就绪（可以通过fork或者exec进行执行）
> * 就绪->执行
> * 执行->就绪  (时间片用完 or 等待子进程)
> * 运行->退出
   
##出现的知识点
> 特权级的转换
> `LAB4`涉及的一些细节